# 基礎編外のコード3
## カーテンコール
カーテンコールコンポーネントの呼び出し元で3秒後にactiveクラスがセットされるようにHooksを使う  
- カーテンコールの表示/非表示の状態を管理するstateを設定
- useEffectのsetTimeout関数内でset関数を呼んで、acvtive状態を管理する
``` jsx
const [active, setActive] = useState(false);
useEffect(() => {
    setTimeout(() => setActive(true), 3000);
  }, []);

return (
    <>
      <Loading active={active} />
```
Propsでactiveの状態を受け取り、三項演算子でクラスを付与する
```jsx
import styles from "./Loading.module.css";

export default function Loading({ active }) {
	return (
		<div className={`${styles.loading} ${active ? styles.isActive : ""}`}>
			<span>～結果発表～</span>
		</div>
	)
}
```
- transition: ease-in-outでいーじんぐと呼ばれる緩急をつけて動かすアニメーションを設定
- Sass同様、&.で複合クラスをネストで定義
```css
.loading {
	position: fixed;
	z-index: 999;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
	background-color: #242424;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 50px;
	transition: transform .5s ease-in-out;

	&.isActive {
		transform: translateY(-100%);
	}
}
```

## 震えるアニメーション
CSSはアニメーションを関数のように定義して反映させたいセレクタにanimationプロパティで呼び出すことで、凝ったアニメーションの実装ができる  
1. @keyframes 名前{ アニメーションの装飾 }を定義
2. セレクタにanimetion: 「名前」を設定
``` css
/* アニメーションが実行された50%の段階でx軸を+3 */
/* アニメーションが実行された100%の段階でx軸を-3 */
@keyframes gakuburu {
	50% {
		transform: translateX(3px);
	}
	100% {
		transform: translateX(-3px);
	}
}

/*　アニメーションを0.1秒ごとに呼び出し、無限ループさせる  */
.loading > span {
	animation: gakuburu .1s infinite;
}
```
